CIYACA-开发文档
~~~~~~~~~~~~~~~~~~~~~~~~


.. toctree::
  :maxdepth: 6

简介
==================

CIYACA 是什么
------------------

.. figure:: ./_static/logo.png

CIYACA 是为北京理工大学《2020年春季Linux 系统编程》大作业而开发的聊天+ BBS 软件，
包括服务端和客户端，均采用 C/CPP 实现。

我们的 Github Organization: https://github.com/ciyaca


.. figure:: ./_static/repo.png

  代码仓库



为什么叫 CIYACA
------------------

CIYACA 采用递归的命名方式， `CIYACA Is Yet Another Chat App` 。

特色与创新之处
===================

- 专门设计了 Logo、名称
- 采用 Github 进行团队协作
- 采用 Sphinx + reStructuredText 进行文档写作
- 采用石墨文档进行共享编辑、整理前期内容
- 设计了美观的界面
  - 有聊天气泡
- 使用 RPC 的方式封装了底层通信，提供耦合度极低的双向调用方式


编译环境和使用方式
====================

编译环境
------------------

目录结构
------------------


使用方式
------------------


功能介绍
====================

基本功能
------------------

.. csv-table:: 基本功能介绍
  :header: "功能名称", "功能介绍"
  :widths: 15, 30

  "联系人树状显示", "将所有联系人按照好友与群组分成两类以树状结构进行呈现。"
  好友请求处理, 主要用于处理好友申请，选择同意或拒绝，并与服务器完成信息交互后删除该请求。 
  单聊, 进行单人聊天。
  表情包发送, 可发送动态表情包。
  文件发送, 可发送图片等文件，发送时聊天界面中间有进度条显示进度。
  添加好友/群组,输入好友名称或群组名称，服务器将返回处理结果，存在该用户则可发送好友请求。
  创建群组,输入群组名称，服务器查询无重复即可创建群组。
  群聊, 进行群组聊天。
  BBS,可进行论坛聊天。


具体功能
------------------

架构设计
====================

整体架构
------------------


模块设计
------------------

界面设计
^^^^^^^^^^^^^^^^^^

本小节讨论客户端的界面设计。

编译环境
""""""""""""""""""

:操作系统: Ubuntu 18.04
:工具:  Qt 5.14.1

注册界面设计思路
""""""""""""""""""

该界面模仿与TIM的登录界面，元素包含logo,登录账号输入框，
登录密码输入框，登录按钮，注册按钮，注册账号输入框，
注册密码输入框、注册密码确认框以及返回按钮，使用Qt自带的ui编辑器对其进行整理。


**细节设计** ：

- 为了避免出现两个窗口，使用QStackedWidget控件来生成两个页面，使用按钮进行切换。点击注册按钮，则出现注册界面，点击返回按钮，则返回到登录界面。
- 为了界面美化，对输入框样式进行了设计，鼠标越过以及点击出现不同颜色，表示选中，同时将框体的四个角变成圆弧，更加接近TIM界面。
- 密码隐藏与展示。在密码输入框的右侧设置一个按钮，来完成密码的隐藏与展示的切换。
- Logo显示，使用label在界面左边显示logo。

主体界面设计思路
""""""""""""""""""
为了做出一个比较好的主体界面，这里也是模仿TIM进行相关设计，
主界面需要展现用户的名字以及头像等信息，然后需要三个子界面：
聊天界面，联系人界面以及BBS界面。这里使用QtabWidget进行分页，分成三个主页面。 

:头像以及名字: 

  当用户成功登陆后，服务器会返回一系列信息，其中包括用户的账户以及头像标签，当前端收到这些信息，将会使用对应Qlabel进行呈现。

:聊天界面设计: 

  类似TIM，聊天界面左边一栏将会出现一个简略的来信信息，右边则是聊天主体界面。对于左边来信消息的实现则是使用QlistWidget类进行呈现，每出现一个新的用户来信，则会在左边新建一行，随即建立对应的聊天主体界面。

  在聊天界面中，最上面一行则是交互信息用户名，然后接着便是消息呈现界面，最下面则是消息发送框，其中增设消息记录，表情包以及文件传输三个按钮，中间还有文件传输进度条的呈现，显示当前文件传输状态。

:联系人界面:

  类似TIM，左边是联系人树状显示，另加上一个添加好友的按钮，在界面实现过程中没有像图中一样分为好友以及群组抽屉，而是放一起，也就是说，左边只有两个分组，一个是“我的好友”，一个是“我的群组”，使用button空间生成一个按钮，完成添加好友/群组功能。对于界面右边，则呈现的是加好友信息的来信提醒。

:添加好友或群组:

  该界面仅有一个输入框，当输入需要添加的用户名称，服务器将会处理请求。

:创建群聊:

  该界面也是仅有一个输入框，输入需要创建的群聊名称，服务器处理请求后返回结果。

:好友申请界面:

  该界面与用户联系人界面在一起，使用QListWidget维护着一个请求列表。对于每一个好友请求，将呈用户头像、用户名以及申请理由，同时设置有同意、拒绝按钮，这些按钮绑定对应的函数与服务端进行交互，一同处理请求。值得注意的是，当点击同意或拒绝后，该请求将从列表中中删除，同时更新请求列表。

网络通信 —— FeverRPC-ng
^^^^^^^^^^^^^^^^^^^^^^^^^^^

FeverRPC-ng 是一个基于 Socket 长连接双向 RPC 框架。

.. note::

  FeverRPC-ng 为 FeverRPC 的重构版，FeverRPC 初版在大三上的时候完成的。

功能
""""""""""""""""""

支持的功能
*****************

- 使用TCP/Socket长连接
- 双向RPC
- 支持任意长度、类型参数绑定
- 基于MsgPack，可自定义序列化类型
- Socket 支持任意大小传输功能 (不超过 int 表示范围的字节数)
- 抛出异常

不支持的功能
******************
- void返回值
- 绑定非静态成员函数

设计目标
""""""""""""""""""

FeverRPC 的设计目标是解决 Socket 通信中客户端和服务端相互调用中的序列化问题。

对于一般程序来说，传统的做法是使用序列化库，每增加一个接口，就需要增加相应的转换代码和序列化、反序列化代码。
然而这对于程序开发显然是个重复而低效的过程，我们可以使用更抽象的方式完成这一功能。

因此，FeverRPC 旨在为客户端和服务端提供如下的通信接口：

.. code-block::
  
  // Client.cpp

  #include "feverrpc.hpp"

  int main(){
      FeverRPC::Client rpc("127.0.0.1");

      // 调用远程的方法
      int ans = rpc.call<int>("add", 1, 2, 3);
  }

.. code-block::

  // Server

  #include "feverrpc.hpp"

  int add(int a, int b, int c){
      return a + b + c;
  }

  int main(){
      FeverRPC::Server rpc;

      // 绑定方法
      rpc.bind("add", add);
      // 监听调用
      rpc.c2s();
  }

可以见到，对于服务端和客户端来说，只需要将自己给对方提供的逻辑绑定，
然后调用者就可以像使用普通函数调用一样，调用远程的逻辑。

为了满足丰富的函数和变量类型，我们也需要提供 **可变长** 的参数调用。

模块架构
""""""""""""""""

.. figure:: ./_static/FerverRPC_arch.png

  FeverRPC 模块架构

:FeverRPC\:\:FeverRPC: *处理函数绑定和函数闭包调用的数据结构和逻辑代码*

  RPC 通信的本质在于事先绑定需要调用的函数，以便在以后的任意时间取出并调用。
  不过如果仅仅是绑定固定参数的函数还不够，我们需要用 CPP 来提供支持任意参数函数
  绑定的功能。这些都由 `FeverRPC::FeverRPC` 实现。

:FeverRPC\:\:Server: *服务端用来监听所有来此客户端的调用的模块*

  封装了服务端监听所用客户端发起通信、主动调用的 Socket 代码。
  通过多线程来处理多个客户端。内部调用 `FeverRPC::FeverRPC` 。

:FeverRPC\:\:Client: *客户端用来监听/调用服务端的模块*

  封装了客户端连接服务端的 Socket 代码，并且使用一个线程监听
  来自服务端的调用。同时也可以主动调用服务端函数。内部调用 `FeverRPC::FeverRPC` 。

:FeverRPC\:\:Factory: *服务端主动调用客户端函数的句柄*

  封装了客户端连接服务端的 Socket 代码，并且返回给上层调用
  一个可以调用客户端函数的句柄。具体的使用方式由上层代码实现。

:上层逻辑控制代码: *客户端/服务端的逻辑代码*

  这些代码又上层实现，在实现的过程中，完全可以屏蔽底层的 Socket 的传输机制。
  在不影响功能的情况下，最大程度上解耦模块。


绑定-执行机制设计
""""""""""""""""""""

RPC 通信需要双方首先绑定可以使用的函数，然后延迟调用。
简单来说，就是使用一个类似 `map<String, Function>` 的映射来
存储这些函数。

在执行的时候，使用根据相应的名称从这个映射中取出函数，并传入参数执行就可以了。


任意类型不定长参数设计
""""""""""""""""""""""""

如果仅仅需要绑定和执行，直接使用强制类型转换将函数参数统一成 `void *` 的方式就行了。
但是我们有一个问题出现了，在双方通信时，变量的类型是无法传递的。如果采用 `void *` 的方式
只能由上层代码将类型强制转换成需要的类型——这样增加了上层代码的工作。

所以我们需要能够在无法泛型的 `map` 中存储函数的类型，也就是让类型变成可以存储的数据。
这就要使用 c++11、c++14 引入的 tuple、变长参数模板、函数参数绑定等功能。简单来说，
这些功能能让我们将参数和返回值的数据类型一同存入 `map` 中。并在需要取回的时候，通过这部分信息
来反序列化传入的参数（以及序列化返回的返回值），保证了 RPC 过程中函数类型的自动转换。

.. note::
  
  具体的代码比较长，详见源码。

任意长数据传送设计
""""""""""""""""""""""""

为了传输不定长的数据，我们需要对于每一个发送的数据，首先传送数据大小，然后按照 1024 字节
分块传送数据。接收端也按照同样的逻辑接受。

Debug 与错误处理设计
""""""""""""""""""""""

为了方便调试，我们可以采用宏定义 + 宏函数的方式自定义 Debug 函数。

.. code-block:: c

  #ifdef DEBUG
  #define dbgprintf(format, args...)                                               \
      printf("[%s,%s,%d] " format "\n", __FILE__, __FUNCTION__, __LINE__, args)
  #define dbgputs(string)                                                          \
      printf("[%s,%s,%d] " string "\n", __FILE__, __FUNCTION__, __LINE__)
  #else
  #define dbgprintf(format, args...)                                               \
      {}
  #define dbgputs(string)                                                          \
      {}
  #endif

这样当我们在 make 的时候传入 `-DDEBUG` flag，就能编译出打印调试信息的代码，
并且每个输出都有文件名、行号、函数名。

双向调用设计
""""""""""""""""""""""""

为了满足交互需求，RPC 不仅仅需要类似 HTTP 的单向无状态请求的方式；还需要提供
从服务端调用客户端的能力（并且在此之上保证能够记忆客户端的身份）。

经管对于 Socket 协议来说，这一切是很好实现的，但是不要忘记我们将 Socket 完全封装了。
因此，上层代码在编译期是无法提前知道这个 RPC 和哪个客户端对应。

:双向调用:
  
  这需要采用两个 Socket 进行通信，分别负责客户端主动发起的调用和服务端主动发起的调用。
  当然，如果采用异步 IO 也可以使用一个 Socket 解决，但是这样需要严格设计消息缓冲的序列，
  会增加较大的工作量、增加调试难度。

:有状态的服务:

  详见 `解决双向调用的身份识别问题`_

  


依赖
""""""""""""""""""

运行依赖
************************

- msgpack
- c++17 (因为使用了 `std::apply`)
- Linux 操作系统

涉及的 Linux 系统调用
*************************

开发者注意事项
""""""""""""""""""

.. warning::

  如果你是一名开发者，这里的内容需要你认真阅读。

为什么你需要它
****************************
why should I use it
你能获得的优势：

在开发阶段，不在需要协商底层通信内容，只需要协商回调函数的接口（可以完全忽略网络传输的问题）。
如果有新增的数据类型，不需要对底层的通信接口进行改动，只需要双方协商好字段和类型就可以。

解决双向调用的身份识别问题
*******************************

在使用双向的 RPC 中会遇到一个棘手的问题，就是在服务端作为 Caller 的代码没有办法知道对应的 Callee 是哪个。 
比如当设计即时通信的服务时，自己 bind 的代码被调用了以后，并不能分清楚要将消息发给哪些 RPC 的对端。

在想了很长时间后我发现这个问题还是需要交给通信协议（交互逻辑）去实现。简单来说， 只要满足以下两条要求就可以获得足够的信息，保证双向调用不会遇到身份认证问题。

1. 客户端除了 login，其他的方法必须首先传入能够标识唯一 ID 的参数信息。
2. 服务端在获得 S2C 的 RPC 连接后，会立刻调用 getID 来获取上一个要求中同样的 ID 信息。

这样，在业务上足够完成身份的绑定，以便后续的操作。

鸣谢
""""""""""""""""""""


- 感谢 button-rpc_ 给予了我最关键的知识点
- 其他能在搜索引擎上找到的相关教程

.. _button-rpc: https://github.com/button-chen/buttonrpc_cpp14

数据库的设计与建立
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

根据最初的需求分析，我们的数据库需要记录好友的申请信息、好友信息、群聊聊天记录、群聊信息、群聊的申请信息、头像信息、私聊记录、私聊信息、未读消息以及每一个账号的信息等，故在设计数据库时设计了friend_apply、friend_info等表，下面将叙述数据库部分重要表的详细信息。

User 表
""""""""""""""""""""""""""""

.. figure:: ./_static/db1.png


User_id代表着账号的唯一索引，有了这一项便能够允许用户给账号创建昵称时能够任意创建而不需考虑重名的问题。

User_name是账号的用户名，同样是账号的唯一索引。

Password是账号的密码，最高支持45位字符。

Signature是账号的个人签名，可以置空。

Online_status是账号的在线状态，可以用来标注好友列表中的在线状态。

Head_portait_id记录着账号的头像，目前头像仅仅是服务器端提供一些预设的图片，不支持用户自定义。

single_chat_info表
""""""""""""""""""""""""""""
.. figure:: ./_static/db2.png


该表利用single_chat_info_id记录了所有有聊天记录的私聊信息以及私聊双方的user_id，便于之后检索聊天信息。

single_chat_history表
""""""""""""""""""""""""""""""

.. figure:: ./_static/db3.png


该表利用chat_info_id与single_chat_info进行连接，可以获得聊天双方的user_id。

time、read、poster_id、content记录了该条信息的时间、已读情况、发送者id以及内容，内容长度被设定为不超过200位字符。

group_chat_info表
""""""""""""""""""""""""""""""

.. figure:: ./_static/db4.png


该表设置了group_chat_info_id作为群聊的唯一索引，群聊管理者可以更改群聊的名称以及任命管理者。

该表将通过记录加入者的user_id，与user表进行连接后便能够获取到所有群聊成员的信息。

group_chat_history表
""""""""""""""""""""""""""""""


.. figure:: ./_static/db5.png

该表同样利用group_chat_info_id作为消息记录的检索方式，使用group_chat_info_id可以查询到该群聊的所有历史信息。

time、read、poster_id、content记录了某一条信息的时间、已读情况、发送者id和信息的内容。

group_chat_management表
""""""""""""""""""""""""""""""


.. figure:: ./_static/db6.png

该表用来记录每个群聊的申请者信息，申请者可以通过group_chat_management_message来向群聊的管理者发出加入群聊的申请信息，管理者审核通过后便将该申请者加入群聊。

friend_apply表
""""""""""""""""""""""""""""""

.. figure:: ./_static/db7.png

该表用来记录用户好友申请信息，object_id代表被申请者的user_id，applicant_id代表申请者的user_id。

申请者可以通过friend_apply_message向被申请者发出好友申请信息，被申请者审核通过后便可以添加为好友。

困难与解决办法
========================

解决双向 RPC 设计中可变长模板参数的设计
--------------------------------------------

难点
^^^^^^^^^^^^^^^

**如何不仅传递数值信息，并且传递类型信息以及根据类型信息自动反序列化** ，是这个 RPC 的最大难点之一。


可变长参数模板的概念实际上是超出一个普通 C/CPP 使用者的认知的。
因为对于传统的编译型语言来说，人们的认知都是：“除了虚函数以外，很难实现运行时多态“。

比如 C 语言中的 `printf` ，虽然支持可变长参数，并且看上去类型任意。但其实这些参数
的类型信息在传递的时候已经被丢弃了，只按照大小压栈。这也是为什么前面还需要用控制字符串
来说明当前变量的信息类型。

而只有在动态语言中，才会有 `print(1, "a", [1,2,3])` 这种不需要提供参数类型信息的方式。
（ `cout << 1 << "a";` 这种相当与多次调用同一个函数，不在我们讨论范围之内）。

所以一开始为了实现我们的动态的 RPC 调用接口，我花了很长时间去考虑该选择怎样的技术来完成它。
也就是，类型信息怎么在网络通信中传输。

原始的方式之所以总需要根据接口修改，就是因为双方通信的时候并没有传递类型信息；或者说这部分
类型信息没有在接收方被正确利用，所以需要双方实现约定好格式的序列化和反序列换。但是我们的希望是:
传递类型信息，并且在接收方动态地反序列化（我们不手动判断）。

解决方法
^^^^^^^^^^^^^^^

还好有可变长参数模板这一概念，以及 CPP11/14/17 中对类型提供的支持，它能够让我们使用  `std::tuple`
类型来装载 Template 中的类型信息。并且通过多级的模板参数展开，我们能够还原其中的类型。

然而这一系列知识以及代码实现还是非常复杂，我用了大概 3 天 × 4 个小时的时间写了两遍，并且参考了一些
网上对于这部分知识的实验性代码，才最终有了今天这版 RPC 的动态参数调用实现。


解决双向 RPC 调用中身份认证的问题
------------------------------------

难点
^^^^^^^^^^^^^^^^^

这版 FeverRPC-ng 是基于大三上完成的初版的进一步重构。在我大三上完成整体设计的时候，
就已经因为这个问题十分头痛。

身份认证的问题是这样的：RPC 调用依赖实现注册的函数，服务端和客户端相互调用属于两个线程。
而如果想在服务端绑定的函数中调用某个具体的 Server to Client 的 RPC 句柄，就会遇到无法确认
具体是哪个句柄的问题。

最初为了解决这个问题。我曾经试图把认证逻辑封装在了 RPC 之中，但是实事证明这样限制了灵活度，
也让 RPC 承担了更复杂而多余的逻辑功能。

解决方法
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

既然代码层面不好约束，在很长时间思考以后，我最终选择了从协议层面入手。

也就是说使用这个 RPC 的上层代码要满足以下的协议要求：


1. 客户端除了 login，其他的方法必须首先传入能够标识唯一 ID 的参数信息。
2. 服务端在获得 S2C 的 RPC 连接后，会立刻调用 getID 来获取上一个要求中同样的 ID 信息。

这样能够保证，首先建立连接的时候服务端就能将句柄和 ID 一一对应，然后在之后的通讯中，
客户端都会提供 ID 来保证服务端能够区分。

这样这个问题就能够比较完美的解决（除了增加性能开销，不过不大）。

分工和人员合作
====================

分工
------------------

合作
------------------

会议记录
^^^^^^^^^^^^^^^^^^

