
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
  <head>
    <meta charset="utf-8" />
    <title>CIYACA-开发文档 &#8212; 《Linux 系统编程》大作业 CIYACA 开发文档 1.0 文档</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="nav-item nav-item-0"><a href="#">《Linux 系统编程》大作业 CIYACA 开发文档 1.0 文档</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">CIYACA-开发文档</a><ul>
<li><a class="reference internal" href="#id1">简介</a><ul>
<li><a class="reference internal" href="#id2">CIYACA 是什么</a></li>
<li><a class="reference internal" href="#id3">为什么叫 CIYACA</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">特色与创新之处</a></li>
<li><a class="reference internal" href="#id5">编译环境和使用方式</a><ul>
<li><a class="reference internal" href="#id6">编译环境</a></li>
<li><a class="reference internal" href="#id7">目录结构</a></li>
<li><a class="reference internal" href="#id8">使用方式</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">功能介绍</a><ul>
<li><a class="reference internal" href="#id10">基本功能</a></li>
<li><a class="reference internal" href="#id11">具体功能</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">架构设计</a><ul>
<li><a class="reference internal" href="#id13">整体架构</a></li>
<li><a class="reference internal" href="#id14">模块设计</a><ul>
<li><a class="reference internal" href="#id15">界面设计</a><ul>
<li><a class="reference internal" href="#id16">编译环境</a></li>
<li><a class="reference internal" href="#id17">注册界面设计思路</a></li>
<li><a class="reference internal" href="#id18">主体界面设计思路</a></li>
</ul>
</li>
<li><a class="reference internal" href="#feverrpc-ng">网络通信 —— FeverRPC-ng</a><ul>
<li><a class="reference internal" href="#id19">功能</a><ul>
<li><a class="reference internal" href="#id20">支持的功能</a></li>
<li><a class="reference internal" href="#id21">不支持的功能</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id22">设计目标</a></li>
<li><a class="reference internal" href="#id23">模块架构</a></li>
<li><a class="reference internal" href="#id24">绑定-执行机制设计</a></li>
<li><a class="reference internal" href="#id25">任意类型不定长参数设计</a></li>
<li><a class="reference internal" href="#id26">任意长数据传送设计</a></li>
<li><a class="reference internal" href="#debug">Debug 与错误处理设计</a></li>
<li><a class="reference internal" href="#id27">双向调用设计</a></li>
<li><a class="reference internal" href="#id28">依赖</a><ul>
<li><a class="reference internal" href="#id29">运行依赖</a></li>
<li><a class="reference internal" href="#linux">涉及的 Linux 系统调用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id30">开发者注意事项</a><ul>
<li><a class="reference internal" href="#id31">为什么你需要它</a></li>
<li><a class="reference internal" href="#id32">解决双向调用的身份识别问题</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id33">鸣谢</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id34">数据库的设计与建立</a><ul>
<li><a class="reference internal" href="#user">User 表</a></li>
<li><a class="reference internal" href="#single-chat-info">single_chat_info表</a></li>
<li><a class="reference internal" href="#single-chat-history">single_chat_history表</a></li>
<li><a class="reference internal" href="#group-chat-info">group_chat_info表</a></li>
<li><a class="reference internal" href="#group-chat-history">group_chat_history表</a></li>
<li><a class="reference internal" href="#group-chat-management">group_chat_management表</a></li>
<li><a class="reference internal" href="#friend-apply">friend_apply表</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id35">困难与解决办法</a><ul>
<li><a class="reference internal" href="#rpc">解决双向 RPC 设计中可变长模板参数的设计</a><ul>
<li><a class="reference internal" href="#id36">难点</a></li>
<li><a class="reference internal" href="#id37">解决方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id38">解决双向 RPC 调用中身份认证的问题</a><ul>
<li><a class="reference internal" href="#id39">难点</a></li>
<li><a class="reference internal" href="#id40">解决方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id41">数据库设计方面</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id42">分工和人员合作</a><ul>
<li><a class="reference internal" href="#id43">分工</a></li>
<li><a class="reference internal" href="#id44">合作</a><ul>
<li><a class="reference internal" href="#id45">会议记录</a><ul>
<li><a class="reference internal" href="#id46">三月九日</a></li>
<li><a class="reference internal" href="#id47">三月十六日</a></li>
<li><a class="reference internal" href="#id48">四月中旬</a></li>
<li><a class="reference internal" href="#id49">五月上旬</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ciyaca">
<h1>CIYACA-开发文档<a class="headerlink" href="#ciyaca" title="永久链接至标题">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="id1">
<h2>简介<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<div class="section" id="id2">
<h3>CIYACA 是什么<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<div class="figure align-default" id="id50">
<img alt="_images/logo.png" src="_images/logo.png" />
<p class="caption"><span class="caption-number">图 1 </span><span class="caption-text">我们设计的 LOGO</span><a class="headerlink" href="#id50" title="永久链接至图片">¶</a></p>
</div>
<p>CIYACA 是为北京理工大学《2020年春季Linux 系统编程》大作业而开发的聊天+ BBS 软件，
包括服务端和客户端，均采用 C/CPP 实现。</p>
<p>我们的 Github Organization: <a class="reference external" href="https://github.com/ciyaca">https://github.com/ciyaca</a></p>
<div class="figure align-default" id="id51">
<img alt="_images/repo.png" src="_images/repo.png" />
<p class="caption"><span class="caption-number">图 2 </span><span class="caption-text">代码仓库</span><a class="headerlink" href="#id51" title="永久链接至图片">¶</a></p>
</div>
</div>
<div class="section" id="id3">
<h3>为什么叫 CIYACA<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>CIYACA 采用递归的命名方式， <cite>CIYACA Is Yet Another Chat App</cite> 。</p>
</div>
</div>
<div class="section" id="id4">
<h2>特色与创新之处<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>专门设计了 Logo、名称</p></li>
<li><p>采用 Github 进行团队协作</p></li>
<li><p>采用 Sphinx + reStructuredText 进行文档写作</p></li>
<li><p>采用石墨文档进行共享编辑、整理前期内容</p></li>
<li><p>设计了美观的界面
- 有聊天气泡</p></li>
<li><p>使用 RPC 的方式封装了底层通信，提供耦合度极低的双向调用方式</p></li>
</ul>
</div>
<div class="section" id="id5">
<h2>编译环境和使用方式<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<div class="section" id="id6">
<h3>编译环境<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="id7">
<h3>目录结构<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="id8">
<h3>使用方式<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
</div>
</div>
<div class="section" id="id9">
<h2>功能介绍<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<div class="section" id="id10">
<h3>基本功能<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<table class="colwidths-given docutils align-default" id="id52">
<caption><span class="caption-number">表 1 </span><span class="caption-text">基本功能介绍</span><a class="headerlink" href="#id52" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>功能名称</p></th>
<th class="head"><p>功能介绍</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>联系人树状显示</p></td>
<td><p>将所有联系人按照好友与群组分成两类以树状结构进行呈现。</p></td>
</tr>
<tr class="row-odd"><td><p>好友请求处理</p></td>
<td><p>主要用于处理好友申请，选择同意或拒绝，并与服务器完成信息交互后删除该请求。</p></td>
</tr>
<tr class="row-even"><td><p>单聊</p></td>
<td><p>进行单人聊天。</p></td>
</tr>
<tr class="row-odd"><td><p>表情包发送</p></td>
<td><p>可发送动态表情包。</p></td>
</tr>
<tr class="row-even"><td><p>文件发送</p></td>
<td><p>可发送图片等文件，发送时聊天界面中间有进度条显示进度。</p></td>
</tr>
<tr class="row-odd"><td><p>添加好友/群组</p></td>
<td><p>输入好友名称或群组名称，服务器将返回处理结果，存在该用户则可发送好友请求。</p></td>
</tr>
<tr class="row-even"><td><p>创建群组</p></td>
<td><p>输入群组名称，服务器查询无重复即可创建群组。</p></td>
</tr>
<tr class="row-odd"><td><p>群聊</p></td>
<td><p>进行群组聊天。</p></td>
</tr>
<tr class="row-even"><td><p>BBS</p></td>
<td><p>可进行论坛聊天。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id11">
<h3>具体功能<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
</div>
</div>
<div class="section" id="id12">
<h2>架构设计<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<div class="section" id="id13">
<h3>整体架构<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<div class="figure align-default" id="system-architect">
<img alt="_images/Linux_系统编程_系统架构.png" src="_images/Linux_系统编程_系统架构.png" />
<p class="caption"><span class="caption-number">图 3 </span><span class="caption-text">系统架构</span><a class="headerlink" href="#system-architect" title="永久链接至图片">¶</a></p>
</div>
<p>如 <a class="reference internal" href="#system-architect"><span class="std std-numref">图 3</span></a> 所示，系统架构分为五个主要的部分（每个模块的具体设计将在下面章节详述）:</p>
<p>TODO</p>
<ul class="simple">
<li><p>QT GUI 模块， 与用户交互并调用底层通讯。详见 <a class="reference internal" href="#id15">界面设计</a> 。</p></li>
<li><p>客户端逻辑代码模块，提供客户端应用逻辑。详见。</p></li>
<li><p>双向 RPC 调用模块，将网络通信封装成函数调用。详见 <a class="reference internal" href="#feverrpc-ng">网络通信 —— FeverRPC-ng</a> 。</p></li>
<li><p>服务端逻辑代码模块，提供服务端应用逻辑。详见。</p></li>
<li><p>数据库调用模块，提供数据持久化支持。详见 <a class="reference internal" href="#id34">数据库的设计与建立</a> 。</p></li>
</ul>
<p><em>注意模块之间的通讯形式各不相同。</em></p>
</div>
<div class="section" id="id14">
<h3>模块设计<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<div class="section" id="id15">
<h4>界面设计<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<p>本小节讨论客户端的界面设计。</p>
<div class="section" id="id16">
<h5>编译环境<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h5>
<dl class="field-list simple">
<dt class="field-odd">操作系统</dt>
<dd class="field-odd"><p>Ubuntu 18.04</p>
</dd>
<dt class="field-even">工具</dt>
<dd class="field-even"><p>Qt 5.14.1</p>
</dd>
</dl>
</div>
<div class="section" id="id17">
<h5>注册界面设计思路<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h5>
<p>该界面模仿与TIM的登录界面，元素包含logo,登录账号输入框，
登录密码输入框，登录按钮，注册按钮，注册账号输入框，
注册密码输入框、注册密码确认框以及返回按钮，使用Qt自带的ui编辑器对其进行整理。</p>
<p><strong>细节设计</strong> ：</p>
<ul class="simple">
<li><p>为了避免出现两个窗口，使用QStackedWidget控件来生成两个页面，使用按钮进行切换。点击注册按钮，则出现注册界面，点击返回按钮，则返回到登录界面。</p></li>
<li><p>为了界面美化，对输入框样式进行了设计，鼠标越过以及点击出现不同颜色，表示选中，同时将框体的四个角变成圆弧，更加接近TIM界面。</p></li>
<li><p>密码隐藏与展示。在密码输入框的右侧设置一个按钮，来完成密码的隐藏与展示的切换。</p></li>
<li><p>Logo显示，使用label在界面左边显示logo。</p></li>
</ul>
</div>
<div class="section" id="id18">
<h5>主体界面设计思路<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h5>
<p>为了做出一个比较好的主体界面，这里也是模仿TIM进行相关设计，
主界面需要展现用户的名字以及头像等信息，然后需要三个子界面：
聊天界面，联系人界面以及BBS界面。这里使用QtabWidget进行分页，分成三个主页面。</p>
<dl class="field-list">
<dt class="field-odd">头像以及名字</dt>
<dd class="field-odd"><p>当用户成功登陆后，服务器会返回一系列信息，其中包括用户的账户以及头像标签，当前端收到这些信息，将会使用对应Qlabel进行呈现。</p>
</dd>
<dt class="field-even">聊天界面设计</dt>
<dd class="field-even"><p>类似TIM，聊天界面左边一栏将会出现一个简略的来信信息，右边则是聊天主体界面。对于左边来信消息的实现则是使用QlistWidget类进行呈现，每出现一个新的用户来信，则会在左边新建一行，随即建立对应的聊天主体界面。</p>
<p>在聊天界面中，最上面一行则是交互信息用户名，然后接着便是消息呈现界面，最下面则是消息发送框，其中增设消息记录，表情包以及文件传输三个按钮，中间还有文件传输进度条的呈现，显示当前文件传输状态。</p>
</dd>
<dt class="field-odd">联系人界面</dt>
<dd class="field-odd"><p>类似TIM，左边是联系人树状显示，另加上一个添加好友的按钮，在界面实现过程中没有像图中一样分为好友以及群组抽屉，而是放一起，也就是说，左边只有两个分组，一个是“我的好友”，一个是“我的群组”，使用button空间生成一个按钮，完成添加好友/群组功能。对于界面右边，则呈现的是加好友信息的来信提醒。</p>
</dd>
<dt class="field-even">添加好友或群组</dt>
<dd class="field-even"><p>该界面仅有一个输入框，当输入需要添加的用户名称，服务器将会处理请求。</p>
</dd>
<dt class="field-odd">创建群聊</dt>
<dd class="field-odd"><p>该界面也是仅有一个输入框，输入需要创建的群聊名称，服务器处理请求后返回结果。</p>
</dd>
<dt class="field-even">好友申请界面</dt>
<dd class="field-even"><p>该界面与用户联系人界面在一起，使用QListWidget维护着一个请求列表。对于每一个好友请求，将呈用户头像、用户名以及申请理由，同时设置有同意、拒绝按钮，这些按钮绑定对应的函数与服务端进行交互，一同处理请求。值得注意的是，当点击同意或拒绝后，该请求将从列表中中删除，同时更新请求列表。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="feverrpc-ng">
<h4>网络通信 —— FeverRPC-ng<a class="headerlink" href="#feverrpc-ng" title="永久链接至标题">¶</a></h4>
<p>FeverRPC-ng 是一个基于 Socket 长连接双向 RPC 框架。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>FeverRPC-ng 为 FeverRPC 的重构版，FeverRPC 初版在大三上的时候完成的。</p>
</div>
<div class="section" id="id19">
<h5>功能<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h5>
<div class="section" id="id20">
<h6>支持的功能<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h6>
<ul class="simple">
<li><p>使用TCP/Socket长连接</p></li>
<li><p>双向RPC</p></li>
<li><p>支持任意长度、类型参数绑定</p></li>
<li><p>基于MsgPack，可自定义序列化类型</p></li>
<li><p>Socket 支持任意大小传输功能 (不超过 int 表示范围的字节数)</p></li>
<li><p>抛出异常</p></li>
</ul>
</div>
<div class="section" id="id21">
<h6>不支持的功能<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h6>
<ul class="simple">
<li><p>void返回值</p></li>
<li><p>绑定非静态成员函数</p></li>
</ul>
</div>
</div>
<div class="section" id="id22">
<h5>设计目标<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h5>
<p>FeverRPC 的设计目标是解决 Socket 通信中客户端和服务端相互调用中的序列化问题。</p>
<p>对于一般程序来说，传统的做法是使用序列化库，每增加一个接口，就需要增加相应的转换代码和序列化、反序列化代码。
然而这对于程序开发显然是个重复而低效的过程，我们可以使用更抽象的方式完成这一功能。</p>
<p>因此，FeverRPC 旨在为客户端和服务端提供如下的通信接口：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Client</span><span class="o">.</span><span class="n">cpp</span>

<span class="c1">#include &quot;feverrpc.hpp&quot;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">FeverRPC</span><span class="p">::</span><span class="n">Client</span> <span class="n">rpc</span><span class="p">(</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">调用远程的方法</span>
    <span class="nb">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">rpc</span><span class="o">.</span><span class="n">call</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Server</span>

<span class="c1">#include &quot;feverrpc.hpp&quot;</span>

<span class="nb">int</span> <span class="n">add</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span> <span class="n">c</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">FeverRPC</span><span class="p">::</span><span class="n">Server</span> <span class="n">rpc</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">绑定方法</span>
    <span class="n">rpc</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">);</span>
    <span class="o">//</span> <span class="n">监听调用</span>
    <span class="n">rpc</span><span class="o">.</span><span class="n">c2s</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以见到，对于服务端和客户端来说，只需要将自己给对方提供的逻辑绑定，
然后调用者就可以像使用普通函数调用一样，调用远程的逻辑。</p>
<p>为了满足丰富的函数和变量类型，我们也需要提供 <strong>可变长</strong> 的参数调用。</p>
</div>
<div class="section" id="id23">
<h5>模块架构<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h5>
<div class="figure align-default" id="id53">
<img alt="_images/FerverRPC_arch.png" src="_images/FerverRPC_arch.png" />
<p class="caption"><span class="caption-number">图 4 </span><span class="caption-text">FeverRPC 模块架构</span><a class="headerlink" href="#id53" title="永久链接至图片">¶</a></p>
</div>
<dl class="field-list">
<dt class="field-odd">FeverRPC::FeverRPC</dt>
<dd class="field-odd"><p><em>处理函数绑定和函数闭包调用的数据结构和逻辑代码</em></p>
<p>RPC 通信的本质在于事先绑定需要调用的函数，以便在以后的任意时间取出并调用。
不过如果仅仅是绑定固定参数的函数还不够，我们需要用 CPP 来提供支持任意参数函数
绑定的功能。这些都由 <cite>FeverRPC::FeverRPC</cite> 实现。</p>
</dd>
<dt class="field-even">FeverRPC::Server</dt>
<dd class="field-even"><p><em>服务端用来监听所有来此客户端的调用的模块</em></p>
<p>封装了服务端监听所用客户端发起通信、主动调用的 Socket 代码。
通过多线程来处理多个客户端。内部调用 <cite>FeverRPC::FeverRPC</cite> 。</p>
</dd>
<dt class="field-odd">FeverRPC::Client</dt>
<dd class="field-odd"><p><em>客户端用来监听/调用服务端的模块</em></p>
<p>封装了客户端连接服务端的 Socket 代码，并且使用一个线程监听
来自服务端的调用。同时也可以主动调用服务端函数。内部调用 <cite>FeverRPC::FeverRPC</cite> 。</p>
</dd>
<dt class="field-even">FeverRPC::Factory</dt>
<dd class="field-even"><p><em>服务端主动调用客户端函数的句柄</em></p>
<p>封装了客户端连接服务端的 Socket 代码，并且返回给上层调用
一个可以调用客户端函数的句柄。具体的使用方式由上层代码实现。</p>
</dd>
<dt class="field-odd">上层逻辑控制代码</dt>
<dd class="field-odd"><p><em>客户端/服务端的逻辑代码</em></p>
<p>这些代码又上层实现，在实现的过程中，完全可以屏蔽底层的 Socket 的传输机制。
在不影响功能的情况下，最大程度上解耦模块。</p>
</dd>
</dl>
</div>
<div class="section" id="id24">
<h5>绑定-执行机制设计<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h5>
<p>RPC 通信需要双方首先绑定可以使用的函数，然后延迟调用。
简单来说，就是使用一个类似 <cite>map&lt;String, Function&gt;</cite> 的映射来
存储这些函数。</p>
<p>在执行的时候，使用根据相应的名称从这个映射中取出函数，并传入参数执行就可以了。</p>
</div>
<div class="section" id="id25">
<h5>任意类型不定长参数设计<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h5>
<p>如果仅仅需要绑定和执行，直接使用强制类型转换将函数参数统一成 <cite>void *</cite> 的方式就行了。
但是我们有一个问题出现了，在双方通信时，变量的类型是无法传递的。如果采用 <cite>void *</cite> 的方式
只能由上层代码将类型强制转换成需要的类型——这样增加了上层代码的工作。</p>
<p>所以我们需要能够在无法泛型的 <cite>map</cite> 中存储函数的类型，也就是让类型变成可以存储的数据。
这就要使用 c++11、c++14 引入的 tuple、变长参数模板、函数参数绑定等功能。简单来说，
这些功能能让我们将参数和返回值的数据类型一同存入 <cite>map</cite> 中。并在需要取回的时候，通过这部分信息
来反序列化传入的参数（以及序列化返回的返回值），保证了 RPC 过程中函数类型的自动转换。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>具体的代码比较长，详见源码。</p>
</div>
</div>
<div class="section" id="id26">
<h5>任意长数据传送设计<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h5>
<p>为了传输不定长的数据，我们需要对于每一个发送的数据，首先传送数据大小，然后按照 1024 字节
分块传送数据。接收端也按照同样的逻辑接受。</p>
</div>
<div class="section" id="debug">
<h5>Debug 与错误处理设计<a class="headerlink" href="#debug" title="永久链接至标题">¶</a></h5>
<p>为了方便调试，我们可以采用宏定义 + 宏函数的方式自定义 Debug 函数。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef DEBUG</span>
<span class="cp">#define dbgprintf(format, args...)                                               \</span>
<span class="cp">    printf(&quot;[%s,%s,%d] &quot; format &quot;\n&quot;, __FILE__, __FUNCTION__, __LINE__, args)</span>
<span class="cp">#define dbgputs(string)                                                          \</span>
<span class="cp">    printf(&quot;[%s,%s,%d] &quot; string &quot;\n&quot;, __FILE__, __FUNCTION__, __LINE__)</span>
<span class="cp">#else</span>
<span class="cp">#define dbgprintf(format, args...)                                               \</span>
<span class="cp">    {}</span>
<span class="cp">#define dbgputs(string)                                                          \</span>
<span class="cp">    {}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>这样当我们在 make 的时候传入 <cite>-DDEBUG</cite> flag，就能编译出打印调试信息的代码，
并且每个输出都有文件名、行号、函数名。</p>
</div>
<div class="section" id="id27">
<h5>双向调用设计<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h5>
<p>为了满足交互需求，RPC 不仅仅需要类似 HTTP 的单向无状态请求的方式；还需要提供
从服务端调用客户端的能力（并且在此之上保证能够记忆客户端的身份）。</p>
<p>经管对于 Socket 协议来说，这一切是很好实现的，但是不要忘记我们将 Socket 完全封装了。
因此，上层代码在编译期是无法提前知道这个 RPC 和哪个客户端对应。</p>
<dl class="field-list simple">
<dt class="field-odd">双向调用</dt>
<dd class="field-odd"><p>这需要采用两个 Socket 进行通信，分别负责客户端主动发起的调用和服务端主动发起的调用。
当然，如果采用异步 IO 也可以使用一个 Socket 解决，但是这样需要严格设计消息缓冲的序列，
会增加较大的工作量、增加调试难度。</p>
</dd>
<dt class="field-even">有状态的服务</dt>
<dd class="field-even"><p>详见 <a class="reference internal" href="#id32">解决双向调用的身份识别问题</a></p>
</dd>
</dl>
</div>
<div class="section" id="id28">
<h5>依赖<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h5>
<div class="section" id="id29">
<h6>运行依赖<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h6>
<ul class="simple">
<li><p>msgpack</p></li>
<li><p>c++17 (因为使用了 <cite>std::apply</cite>)</p></li>
<li><p>Linux 操作系统</p></li>
</ul>
</div>
<div class="section" id="linux">
<h6>涉及的 Linux 系统调用<a class="headerlink" href="#linux" title="永久链接至标题">¶</a></h6>
</div>
</div>
<div class="section" id="id30">
<h5>开发者注意事项<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h5>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>如果你是一名开发者，这里的内容需要你认真阅读。</p>
</div>
<div class="section" id="id31">
<h6>为什么你需要它<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h6>
<p>why should I use it
你能获得的优势：</p>
<p>在开发阶段，不在需要协商底层通信内容，只需要协商回调函数的接口（可以完全忽略网络传输的问题）。
如果有新增的数据类型，不需要对底层的通信接口进行改动，只需要双方协商好字段和类型就可以。</p>
</div>
<div class="section" id="id32">
<h6>解决双向调用的身份识别问题<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h6>
<p>在使用双向的 RPC 中会遇到一个棘手的问题，就是在服务端作为 Caller 的代码没有办法知道对应的 Callee 是哪个。
比如当设计即时通信的服务时，自己 bind 的代码被调用了以后，并不能分清楚要将消息发给哪些 RPC 的对端。</p>
<p>在想了很长时间后我发现这个问题还是需要交给通信协议（交互逻辑）去实现。简单来说， 只要满足以下两条要求就可以获得足够的信息，保证双向调用不会遇到身份认证问题。</p>
<ol class="arabic simple">
<li><p>客户端除了 login，其他的方法必须首先传入能够标识唯一 ID 的参数信息。</p></li>
<li><p>服务端在获得 S2C 的 RPC 连接后，会立刻调用 getID 来获取上一个要求中同样的 ID 信息。</p></li>
</ol>
<p>这样，在业务上足够完成身份的绑定，以便后续的操作。</p>
</div>
</div>
<div class="section" id="id33">
<h5>鸣谢<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h5>
<ul class="simple">
<li><p>感谢 <a class="reference external" href="https://github.com/button-chen/buttonrpc_cpp14">button-rpc</a> 给予了我最关键的知识点</p></li>
<li><p>其他能在搜索引擎上找到的相关教程</p></li>
</ul>
</div>
</div>
<div class="section" id="id34">
<h4>数据库的设计与建立<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h4>
<p>根据最初的需求分析，我们的数据库需要记录好友的申请信息、好友信息、群聊聊天记录、群聊信息、群聊的申请信息、头像信息、私聊记录、私聊信息、未读消息以及每一个账号的信息等，故在设计数据库时设计了friend_apply、friend_info等表，下面将叙述数据库部分重要表的详细信息。</p>
<div class="section" id="user">
<h5>User 表<a class="headerlink" href="#user" title="永久链接至标题">¶</a></h5>
<div class="figure align-default">
<img alt="_images/db1.png" src="_images/db1.png" />
</div>
<p>User_id代表着账号的唯一索引，有了这一项便能够允许用户给账号创建昵称时能够任意创建而不需考虑重名的问题。</p>
<p>User_name是账号的用户名，同样是账号的唯一索引。</p>
<p>Password是账号的密码，最高支持45位字符。</p>
<p>Signature是账号的个人签名，可以置空。</p>
<p>Online_status是账号的在线状态，可以用来标注好友列表中的在线状态。</p>
<p>Head_portait_id记录着账号的头像，目前头像仅仅是服务器端提供一些预设的图片，不支持用户自定义。</p>
</div>
<div class="section" id="single-chat-info">
<h5>single_chat_info表<a class="headerlink" href="#single-chat-info" title="永久链接至标题">¶</a></h5>
<div class="figure align-default">
<img alt="_images/db2.png" src="_images/db2.png" />
</div>
<p>该表利用single_chat_info_id记录了所有有聊天记录的私聊信息以及私聊双方的user_id，便于之后检索聊天信息。</p>
</div>
<div class="section" id="single-chat-history">
<h5>single_chat_history表<a class="headerlink" href="#single-chat-history" title="永久链接至标题">¶</a></h5>
<div class="figure align-default">
<img alt="_images/db3.png" src="_images/db3.png" />
</div>
<p>该表利用chat_info_id与single_chat_info进行连接，可以获得聊天双方的user_id。</p>
<p>time、read、poster_id、content记录了该条信息的时间、已读情况、发送者id以及内容，内容长度被设定为不超过200位字符。</p>
</div>
<div class="section" id="group-chat-info">
<h5>group_chat_info表<a class="headerlink" href="#group-chat-info" title="永久链接至标题">¶</a></h5>
<div class="figure align-default">
<img alt="_images/db4.png" src="_images/db4.png" />
</div>
<p>该表设置了group_chat_info_id作为群聊的唯一索引，群聊管理者可以更改群聊的名称以及任命管理者。</p>
<p>该表将通过记录加入者的user_id，与user表进行连接后便能够获取到所有群聊成员的信息。</p>
</div>
<div class="section" id="group-chat-history">
<h5>group_chat_history表<a class="headerlink" href="#group-chat-history" title="永久链接至标题">¶</a></h5>
<div class="figure align-default">
<img alt="_images/db5.png" src="_images/db5.png" />
</div>
<p>该表同样利用group_chat_info_id作为消息记录的检索方式，使用group_chat_info_id可以查询到该群聊的所有历史信息。</p>
<p>time、read、poster_id、content记录了某一条信息的时间、已读情况、发送者id和信息的内容。</p>
</div>
<div class="section" id="group-chat-management">
<h5>group_chat_management表<a class="headerlink" href="#group-chat-management" title="永久链接至标题">¶</a></h5>
<div class="figure align-default">
<img alt="_images/db6.png" src="_images/db6.png" />
</div>
<p>该表用来记录每个群聊的申请者信息，申请者可以通过group_chat_management_message来向群聊的管理者发出加入群聊的申请信息，管理者审核通过后便将该申请者加入群聊。</p>
</div>
<div class="section" id="friend-apply">
<h5>friend_apply表<a class="headerlink" href="#friend-apply" title="永久链接至标题">¶</a></h5>
<div class="figure align-default">
<img alt="_images/db7.png" src="_images/db7.png" />
</div>
<p>该表用来记录用户好友申请信息，object_id代表被申请者的user_id，applicant_id代表申请者的user_id。</p>
<p>申请者可以通过friend_apply_message向被申请者发出好友申请信息，被申请者审核通过后便可以添加为好友。</p>
</div>
</div>
</div>
</div>
<div class="section" id="id35">
<h2>困难与解决办法<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h2>
<div class="section" id="rpc">
<h3>解决双向 RPC 设计中可变长模板参数的设计<a class="headerlink" href="#rpc" title="永久链接至标题">¶</a></h3>
<div class="section" id="id36">
<h4>难点<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h4>
<p><strong>如何不仅传递数值信息，并且传递类型信息以及根据类型信息自动反序列化</strong> ，是这个 RPC 的最大难点之一。</p>
<p>可变长参数模板的概念实际上是超出一个普通 C/CPP 使用者的认知的。
因为对于传统的编译型语言来说，人们的认知都是：“除了虚函数以外，很难实现运行时多态“。</p>
<p>比如 C 语言中的 <cite>printf</cite> ，虽然支持可变长参数，并且看上去类型任意。但其实这些参数
的类型信息在传递的时候已经被丢弃了，只按照大小压栈。这也是为什么前面还需要用控制字符串
来说明当前变量的信息类型。</p>
<p>而只有在动态语言中，才会有 <cite>print(1, &quot;a&quot;, [1,2,3])</cite> 这种不需要提供参数类型信息的方式。
（ <cite>cout &lt;&lt; 1 &lt;&lt; &quot;a&quot;;</cite> 这种相当与多次调用同一个函数，不在我们讨论范围之内）。</p>
<p>所以一开始为了实现我们的动态的 RPC 调用接口，我花了很长时间去考虑该选择怎样的技术来完成它。
也就是，类型信息怎么在网络通信中传输。</p>
<p>原始的方式之所以总需要根据接口修改，就是因为双方通信的时候并没有传递类型信息；或者说这部分
类型信息没有在接收方被正确利用，所以需要双方实现约定好格式的序列化和反序列换。但是我们的希望是:
传递类型信息，并且在接收方动态地反序列化（我们不手动判断）。</p>
</div>
<div class="section" id="id37">
<h4>解决方法<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h4>
<p>还好有可变长参数模板这一概念，以及 CPP11/14/17 中对类型提供的支持，它能够让我们使用  <cite>std::tuple</cite>
类型来装载 Template 中的类型信息。并且通过多级的模板参数展开，我们能够还原其中的类型。</p>
<p>然而这一系列知识以及代码实现还是非常复杂，我用了大概 3 天 × 4 个小时的时间写了两遍，并且参考了一些
网上对于这部分知识的实验性代码，才最终有了今天这版 RPC 的动态参数调用实现。</p>
</div>
</div>
<div class="section" id="id38">
<h3>解决双向 RPC 调用中身份认证的问题<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h3>
<div class="section" id="id39">
<h4>难点<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h4>
<p>这版 FeverRPC-ng 是基于大三上完成的初版的进一步重构。在我大三上完成整体设计的时候，
就已经因为这个问题十分头痛。</p>
<p>身份认证的问题是这样的：RPC 调用依赖实现注册的函数，服务端和客户端相互调用属于两个线程。
而如果想在服务端绑定的函数中调用某个具体的 Server to Client 的 RPC 句柄，就会遇到无法确认
具体是哪个句柄的问题。</p>
<p>最初为了解决这个问题。我曾经试图把认证逻辑封装在了 RPC 之中，但是实事证明这样限制了灵活度，
也让 RPC 承担了更复杂而多余的逻辑功能。</p>
</div>
<div class="section" id="id40">
<h4>解决方法<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h4>
<p>既然代码层面不好约束，在很长时间思考以后，我最终选择了从协议层面入手。</p>
<p>也就是说使用这个 RPC 的上层代码要满足以下的协议要求：</p>
<ol class="arabic simple">
<li><p>客户端除了 login，其他的方法必须首先传入能够标识唯一 ID 的参数信息。</p></li>
<li><p>服务端在获得 S2C 的 RPC 连接后，会立刻调用 getID 来获取上一个要求中同样的 ID 信息。</p></li>
</ol>
<p>这样能够保证，首先建立连接的时候服务端就能将句柄和 ID 一一对应，然后在之后的通讯中，
客户端都会提供 ID 来保证服务端能够区分。</p>
<p>这样这个问题就能够比较完美的解决（除了增加性能开销，不过不大）。</p>
</div>
</div>
<div class="section" id="id41">
<h3>数据库设计方面<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h3>
<p>作为一名数据库设计与开发者，体会到了在实际的项目开发中，数据库作为最为基础的一个功能，在各个功能的实现中都有涉及。在数据库设计的过程中，我遇到了各种各样的问题，比如各个表间同一字段取名不同导致使用不方便、主键设置不当导致无法插入多条聊天记录……让我体会到设计出一个稳定的数据库是一件非常困难的事情。</p>
</div>
</div>
<div class="section" id="id42">
<h2>分工和人员合作<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h2>
<div class="section" id="id43">
<h3>分工<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h3>
<table class="colwidths-given docutils align-default" id="id54">
<caption><span class="caption-number">表 2 </span><span class="caption-text">成员分工</span><a class="headerlink" href="#id54" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>姓名</p></th>
<th class="head"><p>学号</p></th>
<th class="head"><p>分工</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>董斌</p></td>
<td><p>1120173585</p></td>
<td><p>负责客户端界面的设计和客户端的开发工作，相关文档撰写</p></td>
</tr>
<tr class="row-odd"><td><p>冯开宇</p></td>
<td><p>1120171224</p></td>
<td><p>负责网络通信框架FeverRPC-ng 的开发和维护，相关文档撰写和文档排版，以及项目计划的制定和督促工作</p></td>
</tr>
<tr class="row-even"><td><p>李昌昊</p></td>
<td><p>1120173304</p></td>
<td><p>李昌昊负责数据库的设计与建立，以及相关Mysql语句编写，相关文档撰写</p></td>
</tr>
<tr class="row-odd"><td><p>王占坤</p></td>
<td><p>1120170124</p></td>
<td><p>负责部分客户端的开发和接口的编写工作</p></td>
</tr>
<tr class="row-even"><td><p>张剑威</p></td>
<td><p>1120173586</p></td>
<td><p>张剑威负责后端接口的编写以及各个成员之间的协调工作</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id44">
<h3>合作<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h3>
<p>我们小组在项目开始通过小组会议的方式实现了对项目的大体分工。</p>
<p>在确定好分工后，会定期开展会议来分享大家的进度以及遇到的问题。同时，小组内部部分成员会不定期讨论来决定一些细节问题，比如接口设计问题，并通过及时沟通解决开发上遇到的冲突。我们项目实现了成员职责的明确界定，项目的每个部分都有对应的负责人。我们重视人际协调和沟通，每个人遇到问题，我们大家都会想办法一起解决。通过我们良好的人员合作，我们最终圆满完成了这个项目。</p>
<div class="section" id="id45">
<h4>会议记录<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h4>
<div class="section" id="id46">
<h5>三月九日<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h5>
<dl class="field-list">
<dt class="field-odd">主要内容</dt>
<dd class="field-odd"><p>讨论项目的技术栈，以及明确需求。</p>
</dd>
<dt class="field-even">讨论结果</dt>
<dd class="field-even"><p>我们主要对技术栈进行了分析和选择，比如</p>
<ul class="simple">
<li><p>考虑使用 Rust 来作为后端服务器，稳定性更好</p></li>
<li><p>使用 Github 进行代码协作</p></li>
<li><p>使用 QT 进行客户端开发</p></li>
<li><p>使用 doxygen 进行 C++ 文档管理</p></li>
<li><p>使用 PostgreSQL</p></li>
</ul>
<p>在使用 Rust 的方面我们进行了比较多的讨论，主要是后端的 Rust 其实封装 Linux API 比较多，不太好直接操作 api（因而不是很符合老师的要求）；但是如果采用 C++ + WebSocket 的话，其实自己操作 IO 的部分也很少（会使用大量的库），所以感觉 Rust 并没有不让用。</p>
</dd>
</dl>
</div>
<div class="section" id="id47">
<h5>三月十六日<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h5>
<dl class="field-list simple">
<dt class="field-odd">主要内容</dt>
<dd class="field-odd"><p>确定分工、各自的任务以及下一步的结果。</p>
</dd>
<dt class="field-even">讨论结果</dt>
<dd class="field-even"><p>一开始还是在后端语言的问题上纠结，然后再次向老师确认以后，发现只能用 C/C++ 了。</p>
</dd>
</dl>
</div>
<div class="section" id="id48">
<h5>四月中旬<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h5>
<dl class="field-list simple">
<dt class="field-odd">进度</dt>
<dd class="field-odd"><ul class="simple">
<li><p>GUI：已经有大致的窗体</p></li>
<li><p>数据库: 已经有表了</p></li>
<li><p>RPC: 差不多了，可以进行双向的调用</p></li>
</ul>
</dd>
<dt class="field-even">更多的分析</dt>
<dd class="field-even"><ul class="simple">
<li><p>可以尝试 SQLite 减小运行的要求</p></li>
<li><p>文档可以开始做了</p></li>
<li><p>前后端的逻辑代码可以开始完成了</p></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id49">
<h5>五月上旬<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h5>
<dl class="field-list">
<dt class="field-odd">主要内容</dt>
<dd class="field-odd"><p>是分享目前进度。</p>
<p>客户端与服务端统一接口。</p>
</dd>
</dl>
<p><strong>后续的会议大多以两、三位成员的规模进行召开，涉及到比较细节的问题。因此不再记录。</strong></p>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="nav-item nav-item-0"><a href="#">《Linux 系统编程》大作业 CIYACA 开发文档 1.0 文档</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2020, CIYACA 团队.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4 创建。
    </div>
  </body>
</html>